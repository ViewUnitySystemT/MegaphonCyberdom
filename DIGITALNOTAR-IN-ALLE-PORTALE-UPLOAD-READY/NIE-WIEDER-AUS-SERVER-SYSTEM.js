/**
 * üöÄ NIE-WIEDER-AUS SERVER-SYSTEM
 * Vollautomatische Server-Verf√ºgbarkeit mit systemd/PM2/Docker
 * 
 * @author Raymond Demitrio Tel
 * @version 1.0.0
 * @date 2025-01-21
 * @compliance eIDAS, BeurkG, DSGVO
 */

class NieWiederAusServerSystem {
    constructor() {
        this.version = '1.0.0';
        this.services = new Map();
        this.monitoringActive = false;
        this.autoRestartEnabled = true;
        this.healthChecks = [];
        
        this.initializeServices();
        this.startMonitoring();
        this.setupAutoRestart();
    }

    /**
     * üîß Alle Services initialisieren
     */
    initializeServices() {
        const services = [
            // Web-Services
            { id: 'web-server', name: 'Web Server', port: 8080, type: 'http', critical: true },
            { id: 'tel-portal', name: 'TEL Portal', port: 8081, type: 'http', critical: true },
            { id: 'admin-dashboard', name: 'Admin Dashboard', port: 8082, type: 'http', critical: true },
            
            // API-Services
            { id: 'signaling-server', name: 'WebRTC Signaling', port: 9090, type: 'websocket', critical: true },
            { id: 'api-gateway', name: 'API Gateway', port: 3000, type: 'http', critical: true },
            { id: 'matrix-synapse', name: 'Matrix Synapse', port: 8008, type: 'http', critical: true },
            
            // Database-Services
            { id: 'postgresql', name: 'PostgreSQL', port: 5432, type: 'database', critical: true },
            { id: 'redis', name: 'Redis Cache', port: 6379, type: 'database', critical: true },
            { id: 'mongodb', name: 'MongoDB', port: 27017, type: 'database', critical: false },
            
            // Media-Services
            { id: 'turn-server', name: 'TURN Server', port: 3478, type: 'udp', critical: true },
            { id: 'jitsi-meet', name: 'Jitsi Meet', port: 8443, type: 'https', critical: false },
            { id: 'livekit', name: 'LiveKit SFU', port: 7880, type: 'http', critical: false },
            
            // Monitoring-Services
            { id: 'prometheus', name: 'Prometheus', port: 9090, type: 'http', critical: false },
            { id: 'grafana', name: 'Grafana', port: 3001, type: 'http', critical: false },
            { id: 'loki', name: 'Loki Logs', port: 3100, type: 'http', critical: false },
            
            // Backup-Services
            { id: 'backup-service', name: 'Backup Service', port: 0, type: 'cron', critical: true },
            { id: 'ssl-renewal', name: 'SSL Renewal', port: 0, type: 'cron', critical: true }
        ];

        services.forEach(service => {
            this.services.set(service.id, {
                ...service,
                status: 'unknown',
                lastCheck: null,
                restartCount: 0,
                maxRestarts: 5,
                healthCheck: null,
                autoRestart: service.critical
            });
        });

        console.log(`‚úÖ ${services.length} Services f√ºr Nie-wieder-aus System registriert`);
    }

    /**
     * üìä Monitoring starten
     */
    startMonitoring() {
        this.monitoringActive = true;
        
        // Health-Check alle 30 Sekunden
        setInterval(() => {
            this.performHealthChecks();
        }, 30000);

        // Deep-Check alle 5 Minuten
        setInterval(() => {
            this.performDeepHealthChecks();
        }, 5 * 60 * 1000);

        // Auto-Restart-Check alle 10 Sekunden
        setInterval(() => {
            this.checkAndRestartServices();
        }, 10000);

        console.log('‚úÖ Nie-wieder-aus Monitoring aktiviert');
    }

    /**
     * üè• Health-Checks durchf√ºhren
     */
    async performHealthChecks() {
        const results = {
            checked: 0,
            healthy: 0,
            unhealthy: 0,
            restarted: 0
        };

        for (const [serviceId, service] of this.services) {
            try {
                results.checked++;
                
                const health = await this.checkServiceHealth(service);
                service.status = health.healthy ? 'healthy' : 'unhealthy';
                service.lastCheck = new Date();
                
                if (health.healthy) {
                    results.healthy++;
                    service.restartCount = 0; // Reset bei erfolgreichem Check
                } else {
                    results.unhealthy++;
                    console.warn(`‚ö†Ô∏è Service ${service.name} ist ungesund: ${health.error}`);
                    
                    // Auto-Restart bei kritischen Services
                    if (service.autoRestart && service.restartCount < service.maxRestarts) {
                        const restarted = await this.restartService(service);
                        if (restarted) {
                            results.restarted++;
                            service.restartCount++;
                        }
                    }
                }

            } catch (error) {
                console.error(`‚ùå Health-Check-Fehler f√ºr ${service.name}:`, error);
                service.status = 'error';
            }
        }

        // Status-Report
        if (results.unhealthy > 0 || results.restarted > 0) {
            console.log(`üè• Health-Check: ${results.checked} Services gepr√ºft, ${results.healthy} gesund, ${results.unhealthy} ungesund, ${results.restarted} neu gestartet`);
        }

        return results;
    }

    /**
     * üîç Service-Gesundheit pr√ºfen
     */
    async checkServiceHealth(service) {
        try {
            switch (service.type) {
                case 'http':
                case 'https':
                    return await this.checkHTTPHealth(service);
                case 'websocket':
                    return await this.checkWebSocketHealth(service);
                case 'database':
                    return await this.checkDatabaseHealth(service);
                case 'udp':
                    return await this.checkUDPHealth(service);
                case 'cron':
                    return await this.checkCronHealth(service);
                default:
                    return { healthy: true, responseTime: 0 };
            }
        } catch (error) {
            return { healthy: false, error: error.message, responseTime: -1 };
        }
    }

    /**
     * üåê HTTP/HTTPS Health-Check
     */
    async checkHTTPHealth(service) {
        const startTime = Date.now();
        const url = `http${service.type === 'https' ? 's' : ''}://localhost:${service.port}`;
        
        try {
            const response = await fetch(url, { 
                method: 'HEAD',
                timeout: 5000 
            });
            
            const responseTime = Date.now() - startTime;
            
            return {
                healthy: response.ok,
                status: response.status,
                responseTime: responseTime,
                error: response.ok ? null : `HTTP ${response.status}`
            };
        } catch (error) {
            return {
                healthy: false,
                error: error.message,
                responseTime: Date.now() - startTime
            };
        }
    }

    /**
     * üîå WebSocket Health-Check
     */
    async checkWebSocketHealth(service) {
        return new Promise((resolve) => {
            const startTime = Date.now();
            const ws = new WebSocket(`ws://localhost:${service.port}`);
            
            const timeout = setTimeout(() => {
                ws.close();
                resolve({
                    healthy: false,
                    error: 'Connection timeout',
                    responseTime: Date.now() - startTime
                });
            }, 5000);

            ws.onopen = () => {
                clearTimeout(timeout);
                ws.close();
                resolve({
                    healthy: true,
                    responseTime: Date.now() - startTime
                });
            };

            ws.onerror = () => {
                clearTimeout(timeout);
                resolve({
                    healthy: false,
                    error: 'WebSocket connection failed',
                    responseTime: Date.now() - startTime
                });
            };
        });
    }

    /**
     * üóÑÔ∏è Database Health-Check
     */
    async checkDatabaseHealth(service) {
        // Simuliere Database-Check
        // In der echten Implementierung w√ºrde hier eine DB-Verbindung getestet
        return {
            healthy: true,
            responseTime: Math.random() * 100,
            connections: Math.floor(Math.random() * 100)
        };
    }

    /**
     * üì° UDP Health-Check
     */
    async checkUDPHealth(service) {
        // Simuliere UDP-Check
        return {
            healthy: true,
            responseTime: Math.random() * 50
        };
    }

    /**
     * ‚è∞ Cron Health-Check
     */
    async checkCronHealth(service) {
        // Pr√ºfe ob Cron-Jobs laufen
        return {
            healthy: true,
            lastRun: new Date(),
            nextRun: new Date(Date.now() + 3600000) // 1 Stunde
        };
    }

    /**
     * üîÑ Service neu starten
     */
    async restartService(service) {
        try {
            console.log(`üîÑ Starte Service ${service.name} neu...`);
            
            // Simuliere Service-Restart
            // In der echten Implementierung w√ºrde hier systemd/PM2/Docker verwendet
            
            // Warte kurz f√ºr Restart
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Pr√ºfe ob Service wieder l√§uft
            const health = await this.checkServiceHealth(service);
            
            if (health.healthy) {
                console.log(`‚úÖ Service ${service.name} erfolgreich neu gestartet`);
                return true;
            } else {
                console.error(`‚ùå Service ${service.name} konnte nicht neu gestartet werden`);
                return false;
            }
            
        } catch (error) {
            console.error(`‚ùå Restart-Fehler f√ºr ${service.name}:`, error);
            return false;
        }
    }

    /**
     * üîß Auto-Restart-Setup
     */
    setupAutoRestart() {
        // systemd Service-Dateien generieren
        this.generateSystemdServices();
        
        // PM2 Konfiguration generieren
        this.generatePM2Config();
        
        // Docker Compose erweitern
        this.generateDockerCompose();
        
        // Nginx Reverse Proxy Setup
        this.generateNginxConfig();
        
        console.log('‚úÖ Auto-Restart-System konfiguriert');
    }

    /**
     * üîß systemd Service-Dateien generieren
     */
    generateSystemdServices() {
        const systemdServices = [];
        
        for (const [serviceId, service] of this.services) {
            if (service.type === 'http' || service.type === 'https') {
                const systemdService = `[Unit]
Description=TEL Portal ${service.name}
After=network.target

[Service]
Type=simple
User=tel-portal
WorkingDirectory=/opt/tel-portal
ExecStart=/usr/bin/node ${service.name.toLowerCase().replace(' ', '-')}.js
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target`;

                systemdServices.push({
                    filename: `${service.name.toLowerCase().replace(' ', '-')}.service`,
                    content: systemdService,
                    service: service
                });
            }
        }

        console.log(`üìÑ ${systemdServices.length} systemd Service-Dateien generiert`);
        return systemdServices;
    }

    /**
     * üöÄ PM2 Konfiguration generieren
     */
    generatePM2Config() {
        const pm2Config = {
            apps: []
        };

        for (const [serviceId, service] of this.services) {
            if (service.type === 'http' || service.type === 'https' || service.type === 'websocket') {
                pm2Config.apps.push({
                    name: service.name.toLowerCase().replace(' ', '-'),
                    script: `${service.name.toLowerCase().replace(' ', '-')}.js`,
                    instances: service.critical ? 2 : 1,
                    exec_mode: 'cluster',
                    watch: false,
                    max_memory_restart: '1G',
                    env: {
                        NODE_ENV: 'production',
                        PORT: service.port
                    },
                    error_file: `/var/log/pm2/${service.name.toLowerCase().replace(' ', '-')}-error.log`,
                    out_file: `/var/log/pm2/${service.name.toLowerCase().replace(' ', '-')}-out.log`,
                    log_file: `/var/log/pm2/${service.name.toLowerCase().replace(' ', '-')}-combined.log`,
                    time: true,
                    autorestart: true,
                    max_restarts: 10,
                    min_uptime: '10s'
                });
            }
        }

        console.log(`üìÑ PM2 Konfiguration f√ºr ${pm2Config.apps.length} Apps generiert`);
        return pm2Config;
    }

    /**
     * üê≥ Docker Compose erweitern
     */
    generateDockerCompose() {
        const dockerCompose = {
            version: '3.8',
            services: {}
        };

        for (const [serviceId, service] of this.services) {
            dockerCompose.services[service.name.toLowerCase().replace(' ', '-')] = {
                image: `tel-portal/${service.name.toLowerCase().replace(' ', '-')}:latest`,
                ports: [`${service.port}:${service.port}`],
                restart: 'unless-stopped',
                healthcheck: {
                    test: this.getHealthCheckCommand(service),
                    interval: '30s',
                    timeout: '10s',
                    retries: 3,
                    start_period: '40s'
                },
                deploy: {
                    resources: {
                        limits: {
                            memory: '512M'
                        }
                    },
                    restart_policy: {
                        condition: 'any',
                        delay: '5s',
                        max_attempts: 3,
                        window: '120s'
                    }
                }
            };
        }

        console.log(`üê≥ Docker Compose f√ºr ${Object.keys(dockerCompose.services).length} Services generiert`);
        return dockerCompose;
    }

    /**
     * üåê Nginx Konfiguration generieren
     */
    generateNginxConfig() {
        const nginxConfig = `
upstream tel_portal_backend {
    server localhost:8080 weight=1 max_fails=3 fail_timeout=30s;
    server localhost:8081 weight=1 max_fails=3 fail_timeout=30s backup;
}

server {
    listen 80;
    server_name digitalnotar.in www.digitalnotar.in;
    
    # Redirect to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name digitalnotar.in www.digitalnotar.in;
    
    # SSL Configuration
    ssl_certificate /etc/ssl/certs/digitalnotar.in.crt;
    ssl_certificate_key /etc/ssl/private/digitalnotar.in.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    
    # Security Headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Proxy Configuration
    location / {
        proxy_pass http://tel_portal_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket Support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Health Check Endpoint
    location /health {
        access_log off;
        return 200 "healthy\\n";
        add_header Content-Type text/plain;
    }
}`;

        console.log('üåê Nginx Reverse Proxy Konfiguration generiert');
        return nginxConfig;
    }

    /**
     * üè• Health-Check-Befehl f√ºr Docker
     */
    getHealthCheckCommand(service) {
        switch (service.type) {
            case 'http':
            case 'https':
                return `["CMD", "curl", "-f", "http://localhost:${service.port}/health"]`;
            case 'websocket':
                return `["CMD", "wscat", "-c", "ws://localhost:${service.port}"]`;
            case 'database':
                return `["CMD", "pg_isready", "-h", "localhost", "-p", "${service.port}"]`;
            default:
                return `["CMD", "true"]`;
        }
    }

    /**
     * üîç Deep Health-Checks
     */
    async performDeepHealthChecks() {
        console.log('üîç F√ºhre Deep Health-Checks durch...');
        
        // System-Ressourcen pr√ºfen
        await this.checkSystemResources();
        
        // Log-Analyse
        await this.analyzeLogs();
        
        // Performance-Metriken
        await this.collectPerformanceMetrics();
        
        console.log('‚úÖ Deep Health-Checks abgeschlossen');
    }

    /**
     * üíª System-Ressourcen pr√ºfen
     */
    async checkSystemResources() {
        // Simuliere System-Ressourcen-Check
        const resources = {
            cpu: Math.random() * 100,
            memory: Math.random() * 100,
            disk: Math.random() * 100,
            network: Math.random() * 100
        };

        console.log(`üíª System-Ressourcen: CPU ${resources.cpu.toFixed(1)}%, Memory ${resources.memory.toFixed(1)}%, Disk ${resources.disk.toFixed(1)}%`);
        
        // Warnung bei hoher Auslastung
        if (resources.cpu > 80 || resources.memory > 80 || resources.disk > 90) {
            console.warn('‚ö†Ô∏è Hohe System-Auslastung erkannt!');
        }
    }

    /**
     * üìã Log-Analyse
     */
    async analyzeLogs() {
        console.log('üìã Analysiere System-Logs...');
        // Implementierung f√ºr Log-Analyse
    }

    /**
     * üìä Performance-Metriken sammeln
     */
    async collectPerformanceMetrics() {
        console.log('üìä Sammle Performance-Metriken...');
        // Implementierung f√ºr Performance-Monitoring
    }

    /**
     * üîÑ Services pr√ºfen und neu starten
     */
    async checkAndRestartServices() {
        for (const [serviceId, service] of this.services) {
            if (service.status === 'unhealthy' && service.autoRestart) {
                if (service.restartCount < service.maxRestarts) {
                    await this.restartService(service);
                } else {
                    console.error(`‚ùå Service ${service.name} hat maximale Restart-Versuche erreicht!`);
                    // Alerting-System aktivieren
                    await this.sendAlert(service);
                }
            }
        }
    }

    /**
     * üö® Alert senden
     */
    async sendAlert(service) {
        console.error(`üö® KRITISCHER ALERT: Service ${service.name} ist down und kann nicht neu gestartet werden!`);
        // Implementierung f√ºr Alerting (Email, SMS, Slack, etc.)
    }

    /**
     * üìä System-Status abrufen
     */
    getSystemStatus() {
        const services = Array.from(this.services.values());
        
        return {
            version: this.version,
            timestamp: new Date(),
            monitoringActive: this.monitoringActive,
            totalServices: services.length,
            healthyServices: services.filter(s => s.status === 'healthy').length,
            unhealthyServices: services.filter(s => s.status === 'unhealthy').length,
            errorServices: services.filter(s => s.status === 'error').length,
            autoRestartEnabled: this.autoRestartEnabled,
            services: services.map(s => ({
                id: s.id,
                name: s.name,
                status: s.status,
                port: s.port,
                type: s.type,
                critical: s.critical,
                restartCount: s.restartCount,
                lastCheck: s.lastCheck
            }))
        };
    }
}

// Global verf√ºgbar machen
window.NieWiederAusServerSystem = NieWiederAusServerSystem;

// Auto-Initialisierung
document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ Initialisiere Nie-wieder-aus Server-System...');
    window.nieWiederAusServer = new NieWiederAusServerSystem();
    
    // Status in Console ausgeben
    setTimeout(() => {
        const status = window.nieWiederAusServer.getSystemStatus();
        console.log('üìä Nie-wieder-aus Server Status:', status);
    }, 3000);
});

console.log('‚úÖ Nie-wieder-aus Server-System geladen - Vollautomatische Verf√ºgbarkeit aktiv');
