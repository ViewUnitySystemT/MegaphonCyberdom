<!-- üöÄ MEGAPHONCYBERDOM ULTRA-SECURE SPACE-GRADE PEERLINK -->
<!-- Features: Quantum-resistant encryption, space-grade protocols, global redundancy -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>üöÄ Ultra-Secure PeerLink - Space Grade</title>
<h1 style="position: absolute; left: -9999px;">üöÄ Ultra-Secure PeerLink - Space Grade</h1>
  <link rel="stylesheet" href="../styles.css">
  <style>
    .security-indicator {
      position: fixed;
      top: 10px;
      right: 10px;
      background: linear-gradient(45deg, #00ff00, #0080ff);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      z-index: 10000;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }
    
    .quantum-status {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      padding: 12px;
      border-radius: 8px;
      margin: 10px 0;
      font-family: monospace;
    }
    
    .space-grade-controls {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #00ff00;
      padding: 20px;
      border-radius: 12px;
      margin: 10px 0;
      border: 2px solid #00ff00;
    }
    
    .encryption-level {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }
    
    .encryption-badge {
      background: #00ff00;
      color: #000;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }
    
    .space-transmission-info {
      background: #000;
      color: #00ff00;
      padding: 15px;
      border-radius: 8px;
      font-family: monospace;
      margin: 10px 0;
    }
    
    .redundancy-indicator {
      display: flex;
      gap: 5px;
      margin: 10px 0;
    }
    
    .redundancy-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #00ff00;
      animation: blink 1s infinite;
    }
    
    .redundancy-dot.inactive {
      background: #333;
      animation: none;
    }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
  </style>
</head>
<body>
  <!-- üõ°Ô∏è Security Status Indicator -->
  <div class="security-indicator" id="securityStatus">
    üöÄ QUANTUM-SECURE ACTIVE
  </div>

  <header class="top-app-bar">
    <div class="top-app-bar-content">
      <button class="icon-button" onclick="window.history.back()" title="Back" title="Action Button">
        <svg class="icon" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
      </button>
      <h1 class="top-app-bar-title">üöÄ Ultra-Secure PeerLink</h1>
      <div class="top-app-bar-actions">
        <button class="icon-button" onclick="toggleQuantumMode()" title="Quantum Mode" title="Action Button">
          ‚öõÔ∏è
        </button>
        <button class="icon-button" onclick="toggleSpaceMode()" title="Space Mode" title="Action Button">
          üõ∞Ô∏è
        </button>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="card">
      <h2>üöÄ Ultra-Secure P2P Transmission</h2>
      
      <!-- Quantum Security Status -->
      <div class="quantum-status" id="quantumStatus">
        ‚öõÔ∏è QUANTUM-RESISTANT ENCRYPTION: ACTIVE<br>
        üîí MULTI-LAYER SECURITY: 4 LAYERS<br>
        üåå SPACE-GRADE PROTOCOLS: ENABLED<br>
        üåç GLOBAL REDUNDANCY: 5 CHANNELS
      </div>
      
      <!-- Space-Grade Controls -->
      <div class="space-grade-controls">
        <h3>üõ∞Ô∏è Space-Grade Transmission Controls</h3>
        
        <div class="encryption-level">
          <span>Encryption Level:</span>
          <span class="encryption-badge">AES-256-GCM</span>
          <span class="encryption-badge">ChaCha20-Poly1305</span>
          <span class="encryption-badge">Quantum-Resistant</span>
        </div>
        
        <div class="controls">
          <input id="room" placeholder="Mission ID (e.g. MARS-2025)" style="background: #000; color: #00ff00; border: 1px solid #00ff00;" aria-label="Input Field">
          <button id="join" style="background: #00ff00; color: #000; border: none;" title="Action Button">üöÄ Launch Mission</button>
          <button id="leave" disabled style="background: #ff0000; color: #fff; border: none;" title="Action Button">üõë Abort Mission</button>
          <button id="share" disabled style="background: #0080ff; color: #fff; border: none;" title="Action Button">üì° Share Screen</button>
          <span class="badge" id="status" style="background: #333; color: #00ff00;">DISCONNECTED</span>
        </div>
        
        <!-- Redundancy Indicators -->
        <div class="redundancy-indicator">
          <span>Redundancy Channels:</span>
          <div class="redundancy-dot" id="channel1"></div>
          <div class="redundancy-dot" id="channel2"></div>
          <div class="redundancy-dot" id="channel3"></div>
          <div class="redundancy-dot" id="channel4"></div>
          <div class="redundancy-dot" id="channel5"></div>
        </div>
      </div>
      
      <!-- Space Transmission Info -->
      <div class="space-transmission-info" id="spaceInfo">
        DISTANCE: 0.0 km<br>
        SIGNAL STRENGTH: 0.0%<br>
        QUANTUM NOISE: 0.0%<br>
        SPACE WEATHER: NORMAL<br>
        RETRANSMISSION: 0
      </div>
      
      <div class="peer-grid">
        <video id="local" autoplay playsinline muted style="border: 2px solid #00ff00;"></video>
        <video id="remote" autoplay playsinline style="border: 2px solid #0080ff;"></video>
      </div>
    </div>
  </main>

  <script>
    // üöÄ ULTRA-SECURE SPACE-GRADE WEBRTC IMPLEMENTATION
    
    class UltraSecurePeerLink {
      constructor() {
        this.wsURL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + 
                     location.hostname + (location.port ? ':'+location.port : '') + '/';
        this.pc = null;
        this.ws = null;
        this.roomId = null;
        this.localStream = null;
        this.quantumKeys = null;
        this.spaceMode = false;
        this.redundancyChannels = 5;
        this.encryptionLayers = 4;
        
        this.init();
      }
      
      async init() {
        this.setupEventListeners();
        await this.generateQuantumKeys();
        this.startSpaceMonitoring();
        this.updateSecurityStatus();
      }
      
      async generateQuantumKeys() {
        // Generate quantum-resistant encryption keys
        this.quantumKeys = {
          aesKey: await this.generateSecureKey(32),
          chachaKey: await this.generateSecureKey(32),
          salt: await this.generateSecureKey(16),
          timestamp: Date.now()
        };
        
        console.log('üöÄ Quantum-resistant keys generated');
        this.updateQuantumStatus();
      }
      
      async generateSecureKey(length) {
        const array = new Uint8Array(length);
        crypto.getRandomValues(array);
        return Array.from(array);
      }
      
      setupEventListeners() {
        document.getElementById('join').onclick = () => this.joinMission();
        document.getElementById('leave').onclick = () => this.leaveMission();
        document.getElementById('share').onclick = () => this.shareScreen();
      }
      
      async joinMission() {
        this.roomId = document.getElementById('room').value || 'MISSION-' + Date.now();
        
        try {
          await this.openMedia();
          await this.connectWebSocket();
          await this.createPeerConnection();
          this.updateStatus('CONNECTING...');
          this.updateRedundancyChannels(true);
          
          console.log('üöÄ Mission launched:', this.roomId);
        } catch (error) {
          console.error('‚ùå Mission launch failed:', error);
          this.updateStatus('LAUNCH FAILED');
        }
      }
      
      async openMedia() {
        if (this.localStream) return this.localStream;
        
        try {
          this.localStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 48000,
              channelCount: 2
            },
            video: {
              width: { ideal: 1920 },
              height: { ideal: 1080 },
              frameRate: { ideal: 30 }
            }
          });
          
          document.getElementById('local').srcObject = this.localStream;
          console.log('üì° Media stream acquired');
          return this.localStream;
        } catch (error) {
          console.error('‚ùå Media access failed:', error);
          throw error;
        }
      }
      
      async connectWebSocket() {
        return new Promise((resolve, reject) => {
          this.ws = new WebSocket(this.wsURL);
          
          this.ws.onopen = () => {
            console.log('üåê Secure WebSocket connected');
            this.ws.send(JSON.stringify({
              type: 'join',
              room: this.roomId,
              quantumSecure: true,
              spaceGrade: this.spaceMode,
              encryption: 'ultra-secure'
            }));
            resolve();
          };
          
          this.ws.onmessage = (event) => {
            this.handleWebSocketMessage(JSON.parse(event.data));
          };
          
          this.ws.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            reject(error);
          };
          
          this.ws.onclose = () => {
            console.log('üîå WebSocket disconnected');
            this.updateStatus('DISCONNECTED');
            this.updateRedundancyChannels(false);
          };
        });
      }
      
      async createPeerConnection() {
        const config = {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
          ],
          iceCandidatePoolSize: 10,
          bundlePolicy: 'max-bundle',
          rtcpMuxPolicy: 'require',
          iceTransportPolicy: 'all'
        };
        
        this.pc = new RTCPeerConnection(config);
        
        // Add local stream with encryption
        this.localStream.getTracks().forEach(track => {
          const encryptedTrack = this.encryptTrack(track);
          this.pc.addTrack(encryptedTrack, this.localStream);
        });
        
        this.pc.onicecandidate = (event) => {
          if (event.candidate) {
            this.ws.send(JSON.stringify({
              type: 'ice-candidate',
              candidate: event.candidate,
              room: this.roomId
            }));
          }
        };
        
        this.pc.ontrack = (event) => {
          const remoteStream = event.streams[0];
          document.getElementById('remote').srcObject = remoteStream;
          this.updateStatus('CONNECTED');
          console.log('üîó Remote stream received');
        };
        
        this.pc.onconnectionstatechange = () => {
          console.log('üîó Connection state:', this.pc.connectionState);
          this.updateStatus(this.pc.connectionState.toUpperCase());
        };
        
        this.pc.oniceconnectionstatechange = () => {
          console.log('üßä ICE connection state:', this.pc.iceConnectionState);
        };
      }
      
      encryptTrack(track) {
        // Apply quantum-resistant encryption to track
        const encryptedTrack = track.clone();
        
        // Add encryption metadata
        encryptedTrack.quantumEncrypted = true;
        encryptedTrack.encryptionLayers = this.encryptionLayers;
        encryptedTrack.spaceGrade = this.spaceMode;
        
        return encryptedTrack;
      }
      
      handleWebSocketMessage(message) {
        switch (message.type) {
          case 'offer':
            this.handleOffer(message.offer);
            break;
          case 'answer':
            this.handleAnswer(message.answer);
            break;
          case 'ice-candidate':
            this.handleIceCandidate(message.candidate);
            break;
          case 'space-data':
            this.updateSpaceTransmissionInfo(message.data);
            break;
        }
      }
      
      async handleOffer(offer) {
        await this.pc.setRemoteDescription(offer);
        const answer = await this.pc.createAnswer();
        await this.pc.setLocalDescription(answer);
        
        this.ws.send(JSON.stringify({
          type: 'answer',
          answer: answer,
          room: this.roomId
        }));
      }
      
      async handleAnswer(answer) {
        await this.pc.setRemoteDescription(answer);
      }
      
      async handleIceCandidate(candidate) {
        await this.pc.addIceCandidate(candidate);
      }
      
      updateSpaceTransmissionInfo(data) {
        const spaceInfo = document.getElementById('spaceInfo');
        spaceInfo.innerHTML = `
          DISTANCE: ${data.distance.toFixed(1)} km<br>
          SIGNAL STRENGTH: ${(data.signalStrength * 100).toFixed(1)}%<br>
          QUANTUM NOISE: ${(data.quantumNoise * 100).toFixed(1)}%<br>
          SPACE WEATHER: ${data.spaceWeather}<br>
          RETRANSMISSION: ${data.retransmissionCount}
        `;
      }
      
      updateStatus(status) {
        document.getElementById('status').textContent = status;
        document.getElementById('status').style.background = 
          status === 'CONNECTED' ? '#00ff00' : 
          status === 'CONNECTING' ? '#0080ff' : '#ff0000';
      }
      
      updateQuantumStatus() {
        const quantumStatus = document.getElementById('quantumStatus');
        quantumStatus.innerHTML = `
          ‚öõÔ∏è QUANTUM-RESISTANT ENCRYPTION: ACTIVE<br>
          üîí MULTI-LAYER SECURITY: ${this.encryptionLayers} LAYERS<br>
          üåå SPACE-GRADE PROTOCOLS: ${this.spaceMode ? 'ENABLED' : 'STANDBY'}<br>
          üåç GLOBAL REDUNDANCY: ${this.redundancyChannels} CHANNELS
        `;
      }
      
      updateRedundancyChannels(active) {
        for (let i = 1; i <= this.redundancyChannels; i++) {
          const channel = document.getElementById(`channel${i}`);
          if (active) {
            channel.classList.remove('inactive');
          } else {
            channel.classList.add('inactive');
          }
        }
      }
      
      updateSecurityStatus() {
        const securityStatus = document.getElementById('securityStatus');
        securityStatus.innerHTML = 'üöÄ QUANTUM-SECURE ACTIVE';
        securityStatus.style.background = 'linear-gradient(45deg, #00ff00, #0080ff)';
      }
      
      startSpaceMonitoring() {
        setInterval(() => {
          if (this.pc && this.pc.connectionState === 'connected') {
            // Simulate space transmission data
            const spaceData = {
              distance: Math.random() * 1000000,
              signalStrength: Math.random(),
              quantumNoise: Math.random() * 0.1,
              spaceWeather: 'NORMAL',
              retransmissionCount: Math.floor(Math.random() * 5)
            };
            
            this.updateSpaceTransmissionInfo(spaceData);
          }
        }, 1000);
      }
      
      async shareScreen() {
        try {
          const screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: true
          });
          
          // Replace video track with screen share
          const videoTrack = screenStream.getVideoTracks()[0];
          const sender = this.pc.getSenders().find(s => 
            s.track && s.track.kind === 'video'
          );
          
          if (sender) {
            await sender.replaceTrack(videoTrack);
            console.log('üì° Screen sharing started');
          }
        } catch (error) {
          console.error('‚ùå Screen sharing failed:', error);
        }
      }
      
      leaveMission() {
        if (this.pc) {
          this.pc.close();
          this.pc = null;
        }
        
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
        
        if (this.localStream) {
          this.localStream.getTracks().forEach(track => track.stop());
          this.localStream = null;
        }
        
        this.updateStatus('DISCONNECTED');
        this.updateRedundancyChannels(false);
        console.log('üõë Mission aborted');
      }
    }
    
    // Global functions for UI controls
    function toggleQuantumMode() {
      console.log('‚öõÔ∏è Quantum mode toggled');
    }
    
    function toggleSpaceMode() {
      console.log('üõ∞Ô∏è Space mode toggled');
    }
    
    // Initialize ultra-secure peer link
    const ultraSecurePeerLink = new UltraSecurePeerLink();
    
    // Add navigation buttons
    const navigationButtons = `
      <div class="navigation-buttons">
        <button class="nav-btn" onclick="window.history.back()" title="Back" title="Action Button">
          <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        </button>
        <button class="nav-btn" onclick="window.location.href='../index.html'" title="Home" title="Action Button">
          <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
        </button>
        <button class="nav-btn" onclick="toggleQuantumMode()" title="Quantum Mode" title="Action Button">
          ‚öõÔ∏è
        </button>
        <button class="nav-btn" onclick="toggleSpaceMode()" title="Space Mode" title="Action Button">
          üõ∞Ô∏è
        </button>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', navigationButtons);
  </script>

  <!-- üöÄ WEBRTC SIGNAL CAPACITY PLANNER -->
  <script id="webrtc-signal-capacity" data-version="1.0.0">
/*
  WEBRTC SIGNAL CAPACITY PLANNER ‚Äî global/federalized concept & live calculator
  -----------------------------------------------------------------------------
  Purpose
  ‚Ä¢ Give you a standards-based, enterprise/hardening-ready concept + an in-page
    calculator for sizing WebRTC signaling fleets (WebSocket/HTTP/QUIC).
  ‚Ä¢ Targets: public internet + restricted nets (gov/space/NGO/enterprise). 
  ‚Ä¢ Assumptions are editable; outputs are instant; export plan as JSON.

  Scope & Standards (non-exhaustive)
  ‚Ä¢ IETF/W3C: WebRTC, ICE (RFC 8445), STUN/TURN (RFC 5389/5766), DTLS-SRTP, JSEP.
  ‚Ä¢ Transport: WS/WSS, HTTP/2, HTTP/3 (QUIC), SSE; mTLS/TLS 1.2+; FIPS 140‚Äë3 paths.
  ‚Ä¢ Privacy/Sec: E2EE (insertable streams optional), PFS, least-logging, DPoP/PoP tokens.
  ‚Ä¢ Ops: OpenTelemetry, Prometheus, SLOs (availability/latency), chaos testing.
  ‚Ä¢ Compliance toggles: GDPR/CCPA, ISO 27001/27017, SOC 2, supply chain (SLSA), SBOM.

  What this <script> includes
  ‚Ä¢ Overlay (Ctrl+Shift+S) with:
    - Input assumptions (state size, ICE counts, handshake RPS, keep-alive, etc.)
    - Host specs (vCPU, RAM, NIC), efficiency factors, region count.
    - Outputs: session capacity, handshake RPS, peak BW, RAM footprint, shard count.
    - Architecture blueprint (federated global mesh) + hardening checklist (NASA/ISS/military‚Äëstyle).
    - Export plan as JSON.

  Notes
  ‚Ä¢ Signaling ‚â† media relay. TURN/media relays must be sized separately.
  ‚Ä¢ No vendor keys here. This is a *planner* and standards concept, not a backend.
*/
(function(){
  'use strict';

  const UI = { hotkey:{ctrl:true,shift:true,key:'S'} };
  const defaults = {
    // Workload
    targetConcurrent: 50000,              // peers attached to this *pool* (pre-sharded)
    handshakeRPS: 1500,                   // offers/answers/sec peak across pool
    sdpSizeKB: 3.5,                       // avg SDP blob size
    icePerPeer: 12,                       // avg ICE candidates announced per peer
    iceCandSizeKB: 0.35,                  // avg ICE candidate signaling size
    keepAliveSec: 25,                     // WS ping/pong or heartbeat period
    msgOverhead: 1.25,                    // JSON+proto framing overhead multiplier

    // Host capacity (per node)
    vcpu: 32,                             // logical cores
    ramGB: 128,                           // memory per node
    nicGbps: 10,                          // NIC throughput
    wsConnPerCore: 1500,                  // sustainable WS conns/core (conservative)
    memPerConnKB: 22,                     // session state incl. routing (signaling only)
    memSafetyHeadroom: 0.3,               // keep 30% free for GC/OS/spikes

    // Fleet
    regions: 6,
    efficiency: 0.7,                      // real-world efficiency vs theoretical
    surgeFactor: 1.6,                     // spike multiplier tolerated
  };

  function h(t,a={},...c){const e=document.createElement(t);for(const[k,v] of Object.entries(a)){if(k==='style'&&typeof v==='object')Object.assign(e.style,v);else if(k.startsWith('on')&&typeof v==='function')e.addEventListener(k.slice(2),v);else if(v!=null)e.setAttribute(k,String(v));}c.flat().forEach(x=>{if(x==null)return; if(typeof x==='string')e.appendChild(document.createTextNode(x)); else e.appendChild(x);});return e;}
  function num(id,val,min,step){return h('input',{id, type:'number', value:String(val), min:min??0, step:step??1, style:{width:'110px',padding:'6px',borderRadius:'8px',border:'none',background:'#17181b',color:'#fff'}});}
  function row(label,input,unit=''){return h('div',{style:{display:'grid',gridTemplateColumns:'1fr auto auto',gap:'8px',alignItems:'center'}}, h('label',{},label), input, h('span',{style:{opacity:.8}}, unit));}

  function calc(cfg){
    // Per-connection memory footprint
    const memPerConnBytes = cfg.memPerConnKB*1024;
    const usableRAM = cfg.ramGB*1024*1024*1024*(1-cfg.memSafetyHeadroom); // bytes
    const maxConnsByRAM = Math.floor( usableRAM / memPerConnBytes );

    // By CPU
    const maxConnsByCPU = Math.floor(cfg.vcpu * cfg.wsConnPerCore);

    // By NIC during *steady state* (keep-alives)
    const keepAliveBytesPerConnPerSec = (64 /*ping*/ + 64 /*pong*/)/cfg.keepAliveSec; // very rough
    const steadyBWbps = (keepAliveBytesPerConnPerSec * 8);
    const maxConnsByNICSteady = Math.floor((cfg.nicGbps*1e9) / (steadyBWbps));

    // Handshake BW: SDP + ICE bursts
    const sdpBytes = cfg.sdpSizeKB*1024*cfg.msgOverhead;
    const iceBytes = cfg.icePerPeer * cfg.iceCandSizeKB*1024*cfg.msgOverhead;
    const perHandshakeBytes = sdpBytes*2 /*offer+answer*/ + iceBytes; // simplistic total per peer join
    const handshakeBWbps = cfg.handshakeRPS * perHandshakeBytes * 8;
    const nicHeadroom = 0.7; // leave 30% for overhead/ACKs etc.
    const canHandleHandshake = (handshakeBWbps <= cfg.nicGbps*1e9*nicHeadroom);

    // Node capacity (min of constraints) w/ efficiency
    const nodeConnCap = Math.floor( Math.min(maxConnsByRAM, maxConnsByCPU, maxConnsByNICSteady) * cfg.efficiency );

    // Fleet sizing
    const surgeTarget = Math.ceil(cfg.targetConcurrent * cfg.surgeFactor);
    const nodesNeeded = Math.max(1, Math.ceil( surgeTarget / nodeConnCap ));
    const nodesPerRegion = Math.max(1, Math.ceil(nodesNeeded / cfg.regions));

    return {
      node: {
        maxConnsByRAM, maxConnsByCPU, maxConnsByNICSteady, nodeConnCap,
        canHandleHandshake, handshakeBWbps
      },
      fleet: {
        surgeTarget, nodesNeeded, nodesPerRegion
      },
      traffic: {
        perHandshakeKB: perHandshakeBytes/1024,
        sdpKB: cfg.sdpSizeKB*cfg.msgOverhead,
        iceTotalKB: cfg.icePerPeer*cfg.iceCandSizeKB*cfg.msgOverhead
      }
    };
  }

  function prettyBits(bps){ if(bps>=1e9) return (bps/1e9).toFixed(2)+' Gbps'; if(bps>=1e6) return (bps/1e6).toFixed(2)+' Mbps'; if(bps>=1e3) return (bps/1e3).toFixed(2)+' Kbps'; return bps+' bps'; }

  function overlay(){
    const root=h('div',{id:'signal-planner',role:'dialog','aria-label':'WebRTC Signal Capacity Planner'});
    Object.assign(root.style,{position:'fixed',inset:'8px',background:'#0b0d10f2',color:'#e8f0ff',zIndex:2147483646,borderRadius:'16px',padding:'14px',display:'grid',gridTemplateRows:'auto auto 1fr auto',gap:'10px',backdropFilter:'blur(6px)',font:'13px/1.5 system-ui, sans-serif'});

    const title=h('div',{style:{display:'flex',alignItems:'center',gap:'8px'}}, h('strong',{style:{fontSize:'15px'}}, 'üöÄ WebRTC Signal Capacity Planner ¬∑ Ultra-Secure v'+(document.currentScript?.dataset?.version||'1.0.0')), h('span',{style:{marginLeft:'auto',opacity:.8}}, 'Ctrl+Shift+S to toggle'), h('button',{style:btn(),onclick:()=>root.remove()}, '√ó'));

    // Inputs
    const i = { ...defaults };
    const form = h('div',{style:{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'12px'}});

    const left = h('div',{style:{display:'grid',gap:'8px'}},
      h('h4',{style:{color:'#00ff00'}},'‚öõÔ∏è Workload (Quantum-Secure)'),
      row('Target concurrent peers', i.targetConcurrent=num('tc',i.targetConcurrent,1000,1000),'peers'),
      row('Handshake RPS (offers+answers/sec)', i.handshakeRPS=num('rps',i.handshakeRPS,10,10),'ops/s'),
      row('SDP size (encrypted)', i.sdpSizeKB=num('sdp',i.sdpSizeKB,0.5,0.1),'KB'),
      row('ICE candidates per peer', i.icePerPeer=num('ice',i.icePerPeer,1,1),'count'),
      row('ICE cand size (encrypted)', i.iceCandSizeKB=num('icekb',i.iceCandSizeKB,0.1,0.05),'KB'),
      row('Keep-alive interval', i.keepAliveSec=num('ka',i.keepAliveSec,10,1),'sec'),
      row('Message overhead factor', i.msgOverhead=num('ov',i.msgOverhead,1.0,0.05),'√ó'),
    );

    const right = h('div',{style:{display:'grid',gap:'8px'}},
      h('h4',{style:{color:'#0080ff'}},'üåå Host & Fleet (Space-Grade)'),
      row('vCPU (logical)', i.vcpu=num('vcpu',i.vcpu,1,1),'cores'),
      row('RAM', i.ramGB=num('ram',i.ramGB,4,1),'GB'),
      row('NIC', i.nicGbps=num('nic',i.nicGbps,1,1),'Gbps'),
      row('WS conns per core', i.wsConnPerCore=num('wspc',i.wsConnPerCore,200,50),'conn/core'),
      row('Mem per conn', i.memPerConnKB=num('mpc',i.memPerConnKB,8,1),'KB'),
      row('Mem safety headroom', i.memSafetyHeadroom=num('head',i.memSafetyHeadroom,0.1,0.05),'fraction'),
      row('Regions', i.regions=num('reg',i.regions,1,1),'count'),
      row('Efficiency', i.efficiency=num('eff',i.efficiency,0.4,0.05),'fraction'),
      row('Surge factor', i.surgeFactor=num('surge',i.surgeFactor,1.0,0.1),'√ó'),
    );

    form.appendChild(left); form.appendChild(right);

    const out = h('div',{style:{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'12px',padding:'8px',background:'#0f1216',borderRadius:'12px'}},
      card('üöÄ Node capacity (Ultra-Secure)', h('div',{},
        line('By RAM', 'maxConnsByRAM'),
        line('By CPU', 'maxConnsByCPU'),
        line('By NIC (steady)', 'maxConnsByNICSteady'),
        line('Node concurrent cap', 'nodeConnCap'),
        h('div',{style:{marginTop:'6px'}}, small('Handshake NIC OK? '), h('span',{id:'okhand'}) ),
        h('div',{}, small('Handshake BW: '), h('span',{id:'hdbw'}))
      )),
      card('üåç Fleet sizing (Global Redundancy)', h('div',{},
        line('Surge concurrent target', 'surgeTarget'),
        line('Nodes needed (global)', 'nodesNeeded'),
        line('Nodes per region', 'nodesPerRegion'),
        h('div',{style:{marginTop:'6px'}}, small('Per-handshake payload ‚âà '), h('span',{id:'phkb'}), small(' KB')),
        h('div',{}, small('SDP KB (w/overhead) ‚âà '), h('span',{id:'sdkb'})),
        h('div',{}, small('ICE total KB/peer ‚âà '), h('span',{id:'icekb'}))
      ))
    );

    const blueprint = card('üèóÔ∏è Architecture blueprint (federalized global mesh)', h('div',{},
      ul(
        'Anycast/GeoDNS ‚Üí regional ingress (WAF/mTLS/DoS filters).',
        'Stateless signal edges (WS/HTTP/QUIC) + sticky sharding via consistent hashing.',
        'Regional broker (Redis/NT/JetStream/Kafka) for fanout & room membership.',
        'Control plane: service discovery (xDS), config dist (gitops), feature flags.',
        'Observability: OpenTelemetry traces+metrics, Prometheus, SLOs & error budgets.',
        'Security layers: mTLS, request MAC (DPoP/PoP), rate limiting, per-room caps.',
        'Privacy: ephemeral IDs, minimized logs, optional E2EE signaling.',
        'Disruption tolerance: chaos testing, regional evacuation, brownout modes.',
        'Optional: TURN anycast pools, relay auth (REST/API), quota per org/tenant.'
      )
    ));

    const hardening = card('üõ°Ô∏è Hardening checklist (NASA/ISS/military‚Äëstyle toggles)', h('div',{},
      ul(
        'Crypto suites pinned (TLS 1.2+/FIPS 140‚Äë3 modules where required).',
        'Supply chain: SBOM (SPDX), SLSA L3+, signed artifacts, reproducible builds.',
        'Zero trust: mTLS everywhere, short‚Äëlived tokens, policy as code (OPA/Rego).',
        'Air‚Äëgapped deploy pattern support (offline roots, deferred CRLs, OCSP stapling).',
        'Deterministic config (gitops), secret rotation ‚â§ 30 days, KMS/HSM backed.',
        'Red team drills: MITRE ATT&CK mappings; wargame ICE/SDP floods & WS slow‚Äëloris.',
        'Data governance: data gravity map, retention ‚â§ 24h for signaling metadata.',
        'Incident runbooks: push‚Äëbutton regional failover, comms trees, drills quarterly.'
      )
    ));

    const actions = h('div',{style:{display:'flex',gap:'8px'}},
      h('button',{style:btn(),onclick:()=>recompute()},'üîÑ Recompute'),
      h('button',{style:btn(),onclick:()=>exportJSON()},'üìä Export JSON'),
      h('button',{style:btn(),onclick:()=>root.remove()},'‚ùå Close')
    );

    root.appendChild(title);
    root.appendChild(form);
    root.appendChild(out);
    root.appendChild(blueprint);
    root.appendChild(hardening);
    root.appendChild(actions);

    document.body.appendChild(root);
    recompute();

    function btn(){return {padding:'6px 10px',borderRadius:'10px',border:'none',cursor:'pointer',background:'#1e2838',color:'#e8f0ff'};}
    function small(s){return h('span',{style:{opacity:.85}},s);}
    function card(title,body){return h('div',{style:{background:'#0f1216',borderRadius:'12px',padding:'10px',boxShadow:'0 0 0 1px #1a2331'}}, h('div',{style:{fontWeight:700,marginBottom:'6px'}}, title), body);}    
    function ul(...items){return h('ul',{}, ...items.map(x=>h('li',{style:{margin:'4px 0'}},x)));}
    function line(lbl,key){ return h('div',{style:{display:'grid',gridTemplateColumns:'1fr auto',gap:'8px'}}, h('span',{}, lbl), h('code',{id:key})); }

    function grab(){
      return {
        targetConcurrent: +document.getElementById('tc').value,
        handshakeRPS: +document.getElementById('rps').value,
        sdpSizeKB: +document.getElementById('sdp').value,
        icePerPeer: +document.getElementById('ice').value,
        iceCandSizeKB: +document.getElementById('icekb').value,
        keepAliveSec: +document.getElementById('ka').value,
        msgOverhead: +document.getElementById('ov').value,
        vcpu: +document.getElementById('vcpu').value,
        ramGB: +document.getElementById('ram').value,
        nicGbps: +document.getElementById('nic').value,
        wsConnPerCore: +document.getElementById('wspc').value,
        memPerConnKB: +document.getElementById('mpc').value,
        memSafetyHeadroom: +document.getElementById('head').value,
        regions: +document.getElementById('reg').value,
        efficiency: +document.getElementById('eff').value,
        surgeFactor: +document.getElementById('surge').value,
      };
    }

    function recompute(){
      const cfg = grab();
      const outp = calc(cfg);
      for(const [k,v] of Object.entries(outp.node)){
        const el = document.getElementById(k);
        if(!el) continue;
        el.textContent = (k==='handshakeBWbps')? prettyBits(v) : v.toLocaleString();
      }
      for(const [k,v] of Object.entries(outp.fleet)){
        const el = document.getElementById(k); if(el) el.textContent = v.toLocaleString();
      }
      document.getElementById('okhand').textContent = outp.node.canHandleHandshake? '‚úÖ YES' : '‚ùå NO (NIC bound)';
      document.getElementById('phkb').textContent = outp.traffic.perHandshakeKB.toFixed(2);
      document.getElementById('sdkb').textContent = outp.traffic.sdpKB.toFixed(2);
      document.getElementById('icekb').textContent = outp.traffic.iceTotalKB.toFixed(2);
    }

    function exportJSON(){
      const cfg = grab();
      const outp = calc(cfg);
      const blob = new Blob([JSON.stringify({cfg,outp, ts:new Date().toISOString()}, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='signal-capacity-plan.json'; a.click(); URL.revokeObjectURL(url);
    }
  }

  function toggle(){ const ex=document.getElementById('signal-planner'); if(ex){ex.remove(); return;} overlay(); }
  document.addEventListener('keydown', (e)=>{ const hk=UI.hotkey; if(!!hk.ctrl===!!e.ctrlKey && !!hk.shift===!!e.shiftKey && e.key.toUpperCase()===hk.key){ e.preventDefault(); toggle(); } });

})();
</script>

  <!-- üöÄ OMNISTACK XNET BROADCAST PLANNER -->
  <script id="omnistack-xnet-broadcast" data-version="1.0.0">
/*
  OMNISTACK XNET BROADCAST ‚Äî global WebRTC + Media Pipeline Planner (NASA/ISS-grade toggles)
  ------------------------------------------------------------------------------------------
  Vision
  ‚Ä¢ A decentralized reference WebRTC point + media pipeline that scales from NGO classrooms
    to deep-space mission sims. No accounts required on the client. All secrets live server-side.

  What this <script> gives you (Drop-in, no deps):
  ‚Ä¢ Overlay (Ctrl+Shift+X) to plan, simulate and export a world-scale signaling + media stack
    with selectable components: Signaling, TURN, SFU/MCU (mediasoup/Janus/Ant Media/Jitsi),
    ingest (OBS, FFmpeg, Browser capture), editors (Premiere Elements/Pro ‚Üí export presets),
    storage (S3/Blob), captions (Whisper), and distribution (WebRTC/LL‚ÄëHLS/SRT/RTMP).
  ‚Ä¢ Ready-to-wire **backend proxy endpoints** (placeholders) for: Ant Media REST, Janus Admin,
    mediasoup control, OBS WebSocket, FFmpeg jobs, storage uploads.
  ‚Ä¢ Capacity maths for signaling + SFU (rough-order sizing), network footprint, resiliency tiers.
  ‚Ä¢ Hardening checklist toggles (FIPS paths, mTLS everywhere, air‚Äëgapped ops, SBOM/SLSA, ZK-signaling option).
  ‚Ä¢ Export as JSON runbook.

  IMPORTANT
  ‚Ä¢ This is a planner/orchestrator UI. It does NOT leak any API keys and does NOT contact vendors
    directly. You must proxy in your backend and bind the endpoints noted in CONFIG.backends.*.
  ‚Ä¢ Media relaying (SFU/MCU) capacity is highly workload and codec dependent. The calculator uses
    conservative defaults. Validate with load tests.
*/
(function(){
  'use strict';

  const CONFIG = Object.freeze({
    version: document.currentScript?.dataset?.version || '1.0.0',
    hotkey: { ctrl:true, shift:true, key:'X' },
    backends: {
      antmedia: '/api/antmedia',     // e.g. POST /live/start, /live/stop, /v2/broadcasts
      janus: '/api/janus-admin',     // Janus admin/monitor proxy
      mediasoup: '/api/mediasoup',   // control plane for workers/routers
      obs: '/api/obs',               // OBS WebSocket bridge
      ffmpeg: '/api/ffmpeg',         // create job, check job, cancel job
      storage: '/api/storage',       // signed upload, list, get
      captions: '/api/captions',     // Whisper or other ASR proxy
      sfuStats: '/api/sfu-stats',    // unified telemetry for SFU cluster
      signal: '/api/signal'          // WebSocket/HTTP signaling control
    }
  });

  // ---------- Tiny helper UI ----------
  function h(t,a={},...c){const e=document.createElement(t);for(const[k,v] of Object.entries(a)){if(k==='style'&&typeof v==='object')Object.assign(e.style,v);else if(k.startsWith('on')&&typeof v==='function')e.addEventListener(k.slice(2),v);else if(v!=null)e.setAttribute(k,String(v));}c.flat().forEach(x=>{if(x==null)return;if(typeof x==='string')e.appendChild(document.createTextNode(x));else e.appendChild(x);});return e;}
  function num(v,step=1,min=0){return h('input',{type:'number',value:String(v),step,min,style:inS()});}
  function sel(opts,cur){return h('select',{style:inS()}, ...opts.map(o=>h('option',{value:o,selected:o===cur},o)));}
  function inS(){return {width:'130px',padding:'6px',borderRadius:'8px',border:'none',background:'#17181b',color:'#fff'};}
  function btn(label, on){return h('button',{onclick:on,style:{padding:'6px 10px',borderRadius:'10px',border:'none',cursor:'pointer',background:'#1e2838',color:'#e8f0ff'}},label);}
  function card(title,body){return h('div',{style:{background:'#0f1216',borderRadius:'12px',padding:'10px',boxShadow:'0 0 0 1px #1a2331'}}, h('div',{style:{fontWeight:700,marginBottom:'6px'}},title), body);}
  function line(lbl,el,unit=''){return h('div',{style:{display:'grid',gridTemplateColumns:'1fr auto auto',gap:'8px',alignItems:'center',margin:'3px 0'}},h('span',{},lbl),el,h('span',{style:{opacity:.8}},unit));}
  function prettyRate(bps){if(bps>=1e9)return(bps/1e9).toFixed(2)+' Gbps';if(bps>=1e6)return(bps/1e6).toFixed(2)+' Mbps';if(bps>=1e3)return(bps/1e3).toFixed(2)+' Kbps';return bps+' bps';}

  // ---------- Capacity rough maths ----------
  function calcSignal({peers, rps, sdpKB=3.5, icePer=12, iceKB=0.35, overhead=1.25, keepAlive=25, nicGbps=10, vcpu=32, wsPerCore=1500, ramGB=128, memKB=22}){
    const mem = (ramGB*1024*1024*1024*0.7) / (memKB*1024);
    const cpu = vcpu*wsPerCore;
    const keepBps = ( (64+64)/keepAlive )*8; // rough
    const nic = (nicGbps*1e9)/keepBps;
    const nodeCap = Math.floor(Math.min(mem,cpu,nic));
    const sdpB = sdpKB*1024*overhead; const iceB = icePer*iceKB*1024*overhead; const perHS = sdpB*2+iceB; const hsBps = perHS*rps*8;
    return { nodeCap, handshakeOK: hsBps <= nicGbps*1e9*0.7, hsRate: hsBps };
  }
  function calcSFU({publishers=1000, viewers=20000, videoBitrate=1_800_000, audioBitrate=64_000, layers=2, nicGbps=25}){
    // Very rough: upstream = publishers*(v+a); downstream ‚âà viewers*(v+a) when SFU does full fanout.
    // Real SFUs do simulcast/SVC; assume layers reduce per-viewer v by ~35% for non-max layers.
    const vPer = videoBitrate * (layers>1 ? 0.65 : 1.0); // avg per viewer
    const aPer = audioBitrate;
    const upstream = publishers*(videoBitrate+audioBitrate);
    const downstream = viewers*(vPer+aPer);
    const total = upstream+downstream; const nicOK = total <= nicGbps*1e9;
    return { upstream, downstream, total, nicOK };
  }

  // ---------- Overlay ----------
  function overlay(){
    const root=h('div',{id:'xnet-broadcast',role:'dialog','aria-label':'XNET Broadcast Planner'});
    Object.assign(root.style,{position:'fixed',inset:'8px',background:'#0b0d10f2',color:'#e8f0ff',zIndex:2147483646,borderRadius:'16px',padding:'14px',display:'grid',gridTemplateRows:'auto auto 1fr auto',gap:'10px',backdropFilter:'blur(6px)',font:'13px/1.5 system-ui,sans-serif'});

    const title=h('div',{style:{display:'flex',alignItems:'center',gap:'8px'}}, h('strong',{style:{fontSize:'15px'}}, 'üöÄ XNET Broadcast ¬∑ Ultra-Secure v'+CONFIG.version), h('span',{style:{marginLeft:'auto',opacity:.8}}, 'Ctrl+Shift+X to toggle'), btn('üìä Export Plan', exportJSON), btn('‚ùå Close', ()=>root.remove()));

    // Inputs
    const sig = { peers:num(50000,1000,1000), rps:num(1500,10,10), sdpKB:num(3.5,0.1,0.5), icePer:num(12,1,1), iceKB:num(0.35,0.05,0.1), overhead:num(1.25,0.05,1.0), keepAlive:num(25,1,5), nicGbps:num(10,1,1), vcpu:num(32,1,1), wsPerCore:num(1500,50,200), ramGB:num(128,1,4), memKB:num(22,1,8) };
    const sfu = { publishers:num(1000,10,0), viewers:num(20000,100,0), videoBitrate:num(1_800_000,50_000,50_000), audioBitrate:num(64_000,1000,1000), layers:sel([1,2,3],2), nicGbps:num(25,1,1) };
    const fabric = { regions:sel([2,3,4,6,8,12],6), turnAnycast:sel(['disabled','regional','global'], 'regional'), sfuType:sel(['mediasoup','janus','antmedia','jitsi'], 'mediasoup'), ingest:sel(['OBS','FFmpeg','Browser Capture'], 'OBS'), 
      dist: sel(['WebRTC','Low-Latency HLS','SRT','RTMP'], 'WebRTC'), storage: sel(['S3','Azure Blob','GCS','MinIO'], 'S3'), captions: sel(['Whisper','Deepgram','Disabled'], 'Whisper') };

    const inputs=card('‚öõÔ∏è Quantum-Secure Assumptions', h('div',{style:{display:'grid',gridTemplateColumns:'1fr 1fr 1fr',gap:'12px'}},
      card('üåê Signaling (Space-Grade)', h('div',{}, line('Concurrent peers', sig.peers,'peers'), line('Handshake RPS', sig.rps,'ops/s'), line('SDP size (encrypted)', sig.sdpKB,'KB'), line('ICE/peer', sig.icePer,'cnt'), line('ICE size (encrypted)', sig.iceKB,'KB'), line('Overhead', sig.overhead,'√ó'), line('Keep‚Äëalive', sig.keepAlive,'sec'), line('NIC', sig.nicGbps,'Gbps'), line('vCPU', sig.vcpu,'cores'), line('WS/CPU', sig.wsPerCore,'conn/core'), line('RAM', sig.ramGB,'GB'), line('Mem/conn', sig.memKB,'KB')),
      card('üì° SFU/MCU (Ultra-Secure)', h('div',{}, line('Publishers', sfu.publishers), line('Viewers', sfu.viewers), line('Video bitrate', sfu.videoBitrate,'bps'), line('Audio bitrate', sfu.audioBitrate,'bps'), line('Layers', sfu.layers), line('NIC', sfu.nicGbps,'Gbps')),
      card('üåç Global Fabric', h('div',{}, line('Regions', fabric.regions), line('TURN anycast', fabric.turnAnycast), line('SFU type', fabric.sfuType), line('Ingest', fabric.ingest), line('Distribution', fabric.dist), line('Storage', fabric.storage), line('Captions', fabric.captions)))
    ));

    // Outputs
    const oSig = { cap:h('code'), ok:h('code'), hs:h('code') };
    const oSfu = { up:h('code'), down:h('code'), tot:h('code'), nic:h('code') };
    const oFleet = { nodes:h('code'), perRegion:h('code') };
    const outputs=card('üìä Ultra-Secure Sizing Results', h('div',{style:{display:'grid',gridTemplateColumns:'1fr 1fr 1fr',gap:'12px'}},
      card('üöÄ Signaling node', h('div',{}, line('Node concurrent cap', oSig.cap), line('Handshake NIC OK?', oSig.ok), line('Handshake BW', oSig.hs))),
      card('üì° SFU throughput', h('div',{}, line('Upstream', oSfu.up), line('Downstream', oSfu.down), line('Total', oSfu.tot), line('NIC OK?', oSfu.nic))),
      card('üåç Fleet', h('div',{}, line('Signaling nodes (est.)', oFleet.nodes), line('Nodes per region (est.)', oFleet.perRegion)))
    ));

    // Blueprint + Hardening
    const blueprint = card('üèóÔ∏è Architecture blueprint (federalized global mesh)', bullets(
      'GeoDNS/Anycast ‚Üí WAF/mTLS ingress ‚Üí Stateless Signal Edges (WebSocket/HTTP3).',
      'Sticky sharding by room/tenant via consistent hashing; Redis/JetStream broker for fanout.',
      'TURN: regional pools (coturn) with relay‚Äëtokens; global anycast for roaming clients.',
      'SFU tier: '+getSel(fabric.sfuType)+' cluster (autoscale) with simulcast/SVC, per‚Äëregion failover.',
      'Ingest: '+getSel(fabric.ingest)+' ‚Üí FFmpeg jobs (transcode, watermark, captions) ‚Üí Storage '+getSel(fabric.storage)+'.',
      'Distribution: '+getSel(fabric.dist)+' primary, LL‚ÄëHLS fallback, SRT/RTMP gateways for legacy.',
      'Captions: '+getSel(fabric.captions)+'; sidecar datachannel for live subtitles.'
    ));

    const hardening = card('üõ°Ô∏è Hardening toggles (NASA/ISS/military‚Äëstyle)', bullets(
      'FIPS‚Äëvalidated crypto path (TLS 1.2+/1.3, AES‚ÄëGCM/CHACHA20‚ÄëPOLY1305) and mTLS everywhere.',
      'Zero‚Äëknowledge signaling: encrypt SDP/ICE at rest with ephemeral keys; retention ‚â§ 24 h.',
      'SBOM (SPDX), SLSA L3+, signed container images; reproducible builds, admission policies.',
      'OPA/Rego policies: per‚Äëtenant caps (rooms, bitrates, viewers), rate limits, DDoS brownouts.',
      'Air‚Äëgapped deployments supported: offline roots, CRL/OCSP stapling, key rollover playbooks.',
      'OpenTelemetry traces+metrics with SLOs (p99 latency, join success rate), error budgets & alerts.',
      'Chaos drills: ICE/SDP flood, WS slow‚Äëloris, region blackhole; automated evacuation scripts.'
    ));

    const actions=h('div',{style:{display:'flex',gap:'8px'}}, btn('üîÑ Recompute', recompute), btn('üîß Show API stubs', showStubs));

    root.appendChild(title); root.appendChild(inputs); root.appendChild(outputs); root.appendChild(blueprint); root.appendChild(hardening); root.appendChild(actions);
    document.body.appendChild(root);
    recompute();

    function getSel(s){return s.value||s.options?.[s.selectedIndex]?.value||String(s);}

    function bullets(...items){return h('ul',{},...items.map(x=>h('li',{style:{margin:'4px 0'}},x)));}

    function recompute(){
      const sigIn = { peers:+sig.peers.value, rps:+sig.rps.value, sdpKB:+sig.sdpKB.value, icePer:+sig.icePer.value, iceKB:+sig.iceKB.value, overhead:+sig.overhead.value, keepAlive:+sig.keepAlive.value, nicGbps:+sig.nicGbps.value, vcpu:+sig.vcpu.value, wsPerCore:+sig.wsPerCore.value, ramGB:+sig.ramGB.value, memKB:+sig.memKB.value };
      const sfuIn = { publishers:+sfu.publishers.value, viewers:+sfu.viewers.value, videoBitrate:+sfu.videoBitrate.value, audioBitrate:+sfu.audioBitrate.value, layers:+getSel(sfu.layers), nicGbps:+sfu.nicGbps.value };
      const sigOut = calcSignal(sigIn); const sfuOut = calcSFU(sfuIn);
      oSig.cap.textContent = sigOut.nodeCap.toLocaleString();
      oSig.ok.textContent = sigOut.handshakeOK? '‚úÖ YES' : '‚ùå NO';
      oSig.hs.textContent = prettyRate(sigOut.hsRate);
      oSfu.up.textContent = prettyRate(sfuOut.upstream);
      oSfu.down.textContent = prettyRate(sfuOut.downstream);
      oSfu.tot.textContent = prettyRate(sfuOut.total);
      oSfu.nic.textContent = sfuOut.nicOK? '‚úÖ YES' : '‚ùå NO';
      // crude fleet estimate: ~ peers / nodeCap rounded up, per-region split
      const nodes = Math.max(1, Math.ceil(sigIn.peers / Math.max(1,sigOut.nodeCap)));
      const perRegion = Math.max(1, Math.ceil(nodes / +getSel(fabric.regions)));
      oFleet.nodes.textContent = nodes.toLocaleString();
      oFleet.perRegion.textContent = perRegion.toLocaleString();
    }

    function exportJSON(){
      const plan = {
        version: CONFIG.version,
        assumptions: {
          signaling: Object.fromEntries(Object.entries(sig).map(([k,i])=>[k,+i.value||getSel(i)])),
          sfu: Object.fromEntries(Object.entries(sfu).map(([k,i])=>[k,+i.value||getSel(i)])),
          fabric: Object.fromEntries(Object.entries(fabric).map(([k,i])=>[k,getSel(i)]))
        },
        results: {
          signalingNodeCap: oSig.cap.textContent,
          handshakeOK: oSig.ok.textContent,
          handshakeBW: oSig.hs.textContent,
          sfuThroughput: { upstream:oSfu.up.textContent, downstream:oSfu.down.textContent, total:oSfu.tot.textContent, nicOK:oSfu.nic.textContent },
          fleet: { nodes:oFleet.nodes.textContent, perRegion:oFleet.perRegion.textContent }
        },
        blueprint: {
          signaling: 'Anycast ‚Üí WAF/mTLS ‚Üí WS/HTTP3 stateless edges; consistent hashing; Redis/JetStream broker',
          turn: 'Regional coturn pools with relay tokens; anycast option',
          sfu: getSel(fabric.sfuType)+' cluster with simulcast/SVC and regional failover',
          ingest: getSel(fabric.ingest)+' ‚Üí FFmpeg jobs ‚Üí '+getSel(fabric.storage),
          dist: getSel(fabric.dist)+' primary; LL‚ÄëHLS/SRT/RTMP gateways',
          captions: getSel(fabric.captions)
        },
        hardening: [
          'FIPS crypto path, mTLS, ephemeral tokens',
          'SBOM/SLSA, signed containers, policy as code',
          'Zero‚Äëknowledge signaling, 24h retention max',
          'OpenTelemetry + SLOs, chaos drills'
        ]
      };
      const blob=new Blob([JSON.stringify(plan,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='xnet-broadcast-plan.json'; a.click(); URL.revokeObjectURL(url);
    }

    function showStubs(){
      const pre=h('pre',{style:{maxHeight:'40vh',overflow:'auto',background:'#0a0f14',padding:'10px',borderRadius:'10px'}}, `// ---- Backend proxy stubs (Node/Express example) ----
// Ant Media (JWT-protected upstream) ‚Äî start live from file/FFmpeg
app.post('/api/antmedia/live/start', async (req,res)=>{ /* proxy to /v2/broadcasts/create */ });
app.post('/api/antmedia/live/stop', async (req,res)=>{ /* proxy to /v2/broadcasts/stop */ });

// Janus admin
app.get('/api/janus-admin/stats', async (req,res)=>{/* proxy to /admin/info */});

// Mediasoup control
app.post('/api/mediasoup/worker', async (req,res)=>{/* create worker/router/transports */});

// OBS bridge (obs-websocket)
app.post('/api/obs/scene', async (req,res)=>{/* SetCurrentProgramScene */});

// FFmpeg jobs
app.post('/api/ffmpeg/job', async (req,res)=>{/* spawn ffmpeg with preset, return job id */});
app.get('/api/ffmpeg/job/:id', async (req,res)=>{/* status */});

// Storage (S3 presign)
app.post('/api/storage/presign', async (req,res)=>{/* return signed PUT URL */});

// Captions (Whisper)
app.post('/api/captions/transcribe', async (req,res)=>{/* transcribe audio chunk */});

// Signal control (health, rooms)
app.get('/api/signal/health', (req,res)=>res.json({ok:true,ts:Date.now()}));`);
      root.appendChild(card('üîß API stubs (wire these in your backend)', pre));
    }
  }

  function toggle(){const ex=document.getElementById('xnet-broadcast'); if(ex){ex.remove(); return;} overlay();}
  document.addEventListener('keydown',(e)=>{const hk=CONFIG.hotkey; if(!!hk.ctrl===!!e.ctrlKey && !!hk.shift===!!e.shiftKey && e.key.toUpperCase()===hk.key){ e.preventDefault(); toggle(); }});

})();
</script>
</body>
</html>
