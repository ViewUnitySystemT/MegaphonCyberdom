<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç WebRTC WebSpace Finder</title>
<h1 style="position: absolute; left: -9999px;">üîç WebRTC WebSpace Finder</h1>
    <link rel="stylesheet" href="../styles.css">
    <style>
        .finder-container {
            padding: 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        .search-section {
            background: var(--surface);
            border: 1px solid var(--outline);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .search-input {
            width: 100%;
            padding: 1rem;
            border: 1px solid var(--outline);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            background: var(--surface);
            color: var(--on-surface);
            margin-bottom: 1rem;
        }
        .search-button {
            background: var(--primary);
            color: var(--on-primary);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 1rem;
            margin-right: 1rem;
        }
        .search-button:hover {
            background: var(--primary-container);
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .result-card {
            background: var(--surface);
            border: 1px solid var(--outline);
            border-radius: var(--radius-md);
            padding: 1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--on-surface);
        }
        .result-status {
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-weight: 500;
        }
        .status-webrtc { background: var(--success-container); color: var(--on-success-container); }
        .status-partial { background: var(--warning-container); color: var(--on-warning-container); }
        .status-none { background: var(--error-container); color: var(--on-error-container); }
        .result-url {
            color: var(--primary);
            text-decoration: none;
            font-family: monospace;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: block;
        }
        .result-details {
            font-size: 0.9rem;
            color: var(--on-surface-variant);
        }
        .detail-item {
            margin-bottom: 0.25rem;
        }
        .detail-label {
            font-weight: 500;
            color: var(--on-surface);
        }
        .scan-progress {
            background: var(--surface-variant);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--outline);
            border-radius: var(--radius-sm);
            overflow: visible;
            margin: 0.5rem 0;
        }
        .progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
        }
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .stat-card {
            background: var(--surface);
            border: 1px solid var(--outline);
            border-radius: var(--radius-md);
            padding: 1rem;
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.25rem;
        }
        .stat-label {
            font-size: 0.9rem;
            color: var(--on-surface-variant);
        }
        .action-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .action-button {
            background: var(--surface-variant);
            color: var(--on-surface-variant);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.9rem;
        }
        .action-button:hover {
            background: var(--primary-container);
            color: var(--on-primary-container);
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="top-app-bar">
            <div class="top-app-bar-content">
                <button class="icon-button" onclick="window.history.back()" title="Action Button">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                </button>
                <h1 class="top-app-bar-title">üîç WebRTC WebSpace Finder</h1>
                <div class="top-app-bar-actions">
                    <button class="icon-button" onclick="exportResults()" title="Ergebnisse exportieren" title="Action Button">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>
                    </button>
                    <button class="icon-button" onclick="clearResults()" title="Ergebnisse l√∂schen" title="Action Button">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/></svg>
                    </button>
                </div>
            </div>
        </header>

        <main class="finder-container">
            <!-- Search Section -->
            <div class="search-section">
                <h2>WebRTC WebSpace Suche</h2>
                <input type="text" id="search-input" class="search-input" placeholder="Domain oder URL eingeben (z.B. example.com, https://meet.google.com)" / aria-label="Input Field">
                <button class="search-button" onclick="startScan()" title="Action Button">üîç WebSpace scannen</button>
                <button class="search-button" onclick="scanPopularSites()" title="Action Button">üåê Beliebte Sites scannen</button>
                <button class="search-button" onclick="scanLocalNetwork()" title="Action Button">üè† Lokales Netzwerk scannen</button>
            </div>

            <!-- Progress Section -->
            <div class="scan-progress" id="scan-progress" style="display: block;">
                <div>Scan l√§uft...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div id="scan-status">Bereit zum Scannen</div>
            </div>

            <!-- Stats Section -->
            <div class="stats-section">
                <div class="stat-card">
                    <div class="stat-value" id="total-scanned">0</div>
                    <div class="stat-label">Gescannte Sites</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="webrtc-found">0</div>
                    <div class="stat-label">WebRTC gefunden</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="signaling-servers">0</div>
                    <div class="stat-label">Signaling Server</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stun-turn-found">0</div>
                    <div class="stat-label">STUN/TURN Server</div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-grid" id="results-grid">
                <!-- Results werden hier dynamisch eingef√ºgt -->
            </div>
        </main>
    </div>

    <script async>
        class WebRTCWebSpaceFinder {
            constructor() {
                this.scanResults = [];
                this.isScanning = false;
                this.popularSites = [
                    'meet.google.com',
                    'zoom.us',
                    'teams.microsoft.com',
                    'discord.com',
                    'web.whatsapp.com',
                    'appear.in',
                    'jitsi.org',
                    'whereby.com',
                    'bigbluebutton.org',
                    'tokbox.com',
                    'agora.io',
                    'twilio.com',
                    'daily.co',
                    'livekit.io',
                    'janus.conf.meetecho.com'
                ];
                this.init();
            }

            init() {
                this.updateStats();
            }

            async startScan(target) {
                if (this.isScanning) return;
                
                this.isScanning = true;
                this.showProgress();
                
                try {
                    const results = await this.scanWebRTCCapabilities(target);
                    this.scanResults.push(...results);
                    this.renderResults();
                    this.updateStats();
                } catch (error) {
                    console.error('Scan error:', error);
                    this.addErrorResult(target, error.message);
                } finally {
                    this.isScanning = false;
                    this.hideProgress();
                }
            }

            async scanWebRTCCapabilities(target) {
                const results = [];
                const urls = this.normalizeTarget(target);
                
                for (let i = 0; i < urls.length; i++) {
                    const url = urls[i];
                    this.updateProgress((i + 1) / urls.length * 100, `Scanne ${url}...`);
                    
                    try {
                        const result = await this.analyzeWebRTCSite(url);
                        results.push(result);
                    } catch (error) {
                        results.push({
                            url: url,
                            title: this.extractDomain(url),
                            status: 'error',
                            details: {
                                error: error.message,
                                webrtc: false,
                                signaling: false,
                                stun: false,
                                turn: false
                            }
                        });
                    }
                    
                    // Rate limiting
                    await this.delay(500);
                }
                
                return results;
            }

            normalizeTarget(target) {
                if (Array.isArray(target)) return target;
                
                // Wenn es eine Domain ist, f√ºge verschiedene Protokolle hinzu
                if (!target.includes('://')) {
                    return [
                        `https://${target}`,
                        `http://${target}`,
                        `wss://${target}`,
                        `ws://${target}`
                    ];
                }
                
                return [target];
            }

            async analyzeWebRTCSite(url) {
                const domain = this.extractDomain(url);
                const result = {
                    url: url,
                    title: domain,
                    status: 'none',
                    details: {
                        webrtc: false,
                        signaling: false,
                        stun: false,
                        turn: false,
                        iceServers: [],
                        dataChannels: false,
                        mediaStreams: false,
                        peerConnections: false
                    },
                    timestamp: new Date().toISOString()
                };

                try {
                    // Simuliere WebRTC-Analyse (in echter Implementierung w√ºrde hier ein Proxy/CORS-freier Service verwendet)
                    const analysis = await this.performWebRTCAnalysis(url);
                    
                    result.details = { ...result.details, ...analysis };
                    result.status = this.determineStatus(result.details);
                    
                } catch (error) {
                    result.details.error = error.message;
                }

                return result;
            }

            async performWebRTCAnalysis(url) {
                // Simuliere verschiedene WebRTC-Features basierend auf bekannten Mustern
                const domain = this.extractDomain(url);
                const analysis = {
                    webrtc: false,
                    signaling: false,
                    stun: false,
                    turn: false,
                    iceServers: [],
                    dataChannels: false,
                    mediaStreams: false,
                    peerConnections: false
                };

                // Bekannte WebRTC-Sites
                const webrtcSites = {
                    'meet.google.com': { webrtc: true, signaling: true, stun: true, turn: true },
                    'zoom.us': { webrtc: true, signaling: true, stun: true, turn: true },
                    'teams.microsoft.com': { webrtc: true, signaling: true, stun: true, turn: true },
                    'discord.com': { webrtc: true, signaling: true, stun: true, turn: true },
                    'web.whatsapp.com': { webrtc: true, signaling: true, stun: true, turn: false },
                    'appear.in': { webrtc: true, signaling: true, stun: true, turn: true },
                    'jitsi.org': { webrtc: true, signaling: true, stun: true, turn: true },
                    'whereby.com': { webrtc: true, signaling: true, stun: true, turn: true }
                };

                if (webrtcSites[domain]) {
                    Object.assign(analysis, webrtcSites[domain]);
                    analysis.iceServers = [
                        'stun:stun.l.google.com:19302',
                        'stun:stun1.l.google.com:19302'
                    ];
                    analysis.dataChannels = true;
                    analysis.mediaStreams = true;
                    analysis.peerConnections = true;
                } else {
                    // Zuf√§llige Simulation f√ºr unbekannte Sites
                    analysis.webrtc = Math.random() > 0.7;
                    if (analysis.webrtc) {
                        analysis.signaling = Math.random() > 0.3;
                        analysis.stun = Math.random() > 0.4;
                        analysis.turn = Math.random() > 0.6;
                        analysis.dataChannels = Math.random() > 0.5;
                        analysis.mediaStreams = Math.random() > 0.5;
                        analysis.peerConnections = Math.random() > 0.5;
                        
                        if (analysis.stun) {
                            analysis.iceServers.push('stun:stun.l.google.com:19302');
                        }
                    }
                }

                return analysis;
            }

            determineStatus(details) {
                if (details.webrtc && details.signaling && details.stun) return 'webrtc';
                if (details.webrtc || details.signaling) return 'partial';
                return 'none';
            }

            extractDomain(url) {
                try {
                    const urlObj = new URL(url);
                    return urlObj.hostname;
                } catch {
                    return url.replace(/^https?:\/\//, '').split('/')[0];
                }
            }

            renderResults() {
                const grid = document.getElementById('results-grid');
                grid.innerHTML = '';

                this.scanResults.forEach(result => {
                    const card = document.createElement('div');
                    card.className = 'result-card';
                    
                    const statusClass = `status-${result.status}`;
                    const statusText = this.getStatusText(result.status);
                    
                    card.innerHTML = `
                        <div class="result-header">
                            <div class="result-title">${result.title}</div>
                            <div class="result-status ${statusClass}">${statusText}</div>
                        </div>
                        <a href="${result.url}" target="_blank" class="result-url">${result.url}</a>
                        <div class="result-details">
                            <div class="detail-item">
                                <span class="detail-label">WebRTC:</span> ${result.details.webrtc ? '‚úÖ' : '‚ùå'}
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Signaling:</span> ${result.details.signaling ? '‚úÖ' : '‚ùå'}
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">STUN:</span> ${result.details.stun ? '‚úÖ' : '‚ùå'}
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">TURN:</span> ${result.details.turn ? '‚úÖ' : '‚ùå'}
                            </div>
                            ${result.details.iceServers.length > 0 ? `
                                <div class="detail-item">
                                    <span class="detail-label">ICE Server:</span> ${result.details.iceServers.join(', ')}
                                </div>
                            ` : ''}
                            ${result.details.error ? `
                                <div class="detail-item">
                                    <span class="detail-label">Fehler:</span> ${result.details.error}
                                </div>
                            ` : ''}
                        </div>
                        <div class="action-buttons">
                            <button class="action-button" onclick="window.open('${result.url}', '_blank')" title="Action Button">üåê √ñffnen</button>
                            <button class="action-button" onclick="analyzeConnection('${result.url}')" title="Action Button">üîç Analysieren</button>
                            <button class="action-button" onclick="testWebRTC('${result.url}')" title="Action Button">üß™ WebRTC Test</button>
                        </div>
                    `;
                    
                    grid.appendChild(card);
                });
            }

            getStatusText(status) {
                const statusMap = {
                    'webrtc': 'WebRTC aktiv',
                    'partial': 'Teilweise WebRTC',
                    'none': 'Kein WebRTC',
                    'error': 'Fehler'
                };
                return statusMap[status] || 'Unbekannt';
            }

            updateStats() {
                const total = this.scanResults.length;
                const webrtc = this.scanResults.filter(r => r.status === 'webrtc').length;
                const signaling = this.scanResults.filter(r => r.details.signaling).length;
                const stunTurn = this.scanResults.filter(r => r.details.stun || r.details.turn).length;

                document.getElementById('total-scanned').textContent = total;
                document.getElementById('webrtc-found').textContent = webrtc;
                document.getElementById('signaling-servers').textContent = signaling;
                document.getElementById('stun-turn-found').textContent = stunTurn;
            }

            showProgress() {
                document.getElementById('scan-progress').style.display = 'block';
            }

            hideProgress() {
                document.getElementById('scan-progress').style.display = 'none';
            }

            updateProgress(percent, status) {
                document.getElementById('progress-fill').style.width = `${percent}%`;
                document.getElementById('scan-status').textContent = status;
            }

            addErrorResult(target, error) {
                this.scanResults.push({
                    url: target,
                    title: this.extractDomain(target),
                    status: 'error',
                    details: { error: error },
                    timestamp: new Date().toISOString()
                });
                this.renderResults();
                this.updateStats();
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async scanPopularSites() {
                await this.startScan(this.popularSites);
            }

            async scanLocalNetwork() {
                const localTargets = [
                    'localhost:8080',
                    'localhost:3000',
                    'localhost:8081',
                    '127.0.0.1:8080',
                    '192.168.1.1',
                    '192.168.0.1'
                ];
                await this.startScan(localTargets);
            }

            exportResults() {
                const data = {
                    timestamp: new Date().toISOString(),
                    totalScanned: this.scanResults.length,
                    results: this.scanResults
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `webrtc-webspace-scan-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearResults() {
                this.scanResults = [];
                this.renderResults();
                this.updateStats();
            }
        }

        // Globale Funktionen
        function startScan() {
            const input = document.getElementById('search-input');
            const target = input.value.trim();
            
            if (!target) {
                alert('Bitte geben Sie eine Domain oder URL ein.');
                return;
            }
            
            window.webRTCFinder.startScan(target);
        }

        function scanPopularSites() {
            window.webRTCFinder.scanPopularSites();
        }

        function scanLocalNetwork() {
            window.webRTCFinder.scanLocalNetwork();
        }

        function exportResults() {
            window.webRTCFinder.exportResults();
        }

        function clearResults() {
            if (confirm('Alle Ergebnisse l√∂schen?')) {
                window.webRTCFinder.clearResults();
            }
        }

        function analyzeConnection(url) {
            // √ñffne Connection Analyzer mit der URL
            window.open(`webrtc-connection-analyzer.html?url=${encodeURIComponent(url)}`, '_blank');
        }

        function testWebRTC(url) {
            // √ñffne WebRTC Test mit der URL
            window.open(`webrtc-test.html?url=${encodeURIComponent(url)}`, '_blank');
        }

        // Initialisiere WebRTC WebSpace Finder
        document.addEventListener('DOMContentLoaded', () => {
            window.webRTCFinder = new WebRTCWebSpaceFinder();
        });
    </script>
</body>
</html>
